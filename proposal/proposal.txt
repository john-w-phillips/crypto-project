Abstract

There have been catastrophic but small modifications to openssl in the
past[1][2] that drastically reduced the potential number of keys that
could be generated during key generation. We'd like to see if a
similar vulnerability that is easy to exploit could still be
introduced into the codebase with a small modification to the base
source of openssl.


Introduction

Background:

In 2008 a debian developer made a patch to openssl to fix valgrind
warnings[2][3]. Parts of openssl were deliberately using uninitialized
memory to add entropy for key generation, and this caused client
programs that linked to openssl to generate error/warnings when
developers tried to validate programs with valgrind. However, without
this extra entropy the number of possible keys was drastically
reduced. This was a very small code change that resulted in a very
easy exploit. Programs like ssh that used openssl to generate keys now
only had a few thousand potential keys [3].

Motivation

We'd like to dig into the current and past source code of openssl,
understand the first exploit referenced in [1] in the old code, and
see if a similar exploit is still easy to introduce and
reproduce. We'd also like to get a sense of how hard it would be for a
malicious actor to introduce another similar exploit into the code, or
a similar mistake to happen.

Goal

We'd like to reproduce the 2008 bug and demonstrate a working exploit
(i.e. we'd like to derive a key and decrypt a file for example), and
show that it could be very simple for a disgruntled employee or
malicious actor to introduce a small patch to openssl in a downstream
distribution (or potentially to the project itself) that could make it
very vulnerable, or alternatively demonstrate that the codebase has
improved and is much harder to accidentally exploit this way. We may
also investigate the current process in the debian distribution and
the openssl project for adding patches.


Key idea/approach

We'd like to fork a current openssl version, see if we can make a
small modification to the code that reduces the possible number of
keys. This modification should be similar to the exploit in [1] in
that it is a small number of lines of code that decreases entropy for
key generation, making it easier to guess the private key generated by
openssl.

Then we would create a small program that can guess the key in a
reasonable amount of time since it knows that the keyspace is now much
smaller. We could then for example forge a signature or decrypt a file
encrypted with the public key.


Expected results

A runnable 'exploit' that works on a modified openssl. This should
demonstrate that it only takes a small change to openssl that could be
made in any number of places to decrease the potential keyspace for
private keys.

Conclusion

We'd like to create an easy-to-exploit vulnerability in the current
openssl source that is similar to the one inadvertently introduced
into the debian source code in 2008 [1]. If it's still possible to
make such a change, this raises concerns about the security of an open
source security-critical system like openssl.

References

[1] https://isotoma.com/blog/2008/05/14/debians-openssl-disaster/

[2] https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=363516

[3] https://research.swtch.com/openssl

[4] [ CVE # ]
